From ae7ac38340c706987069b40e32cac324a2e6ea29 Mon Sep 17 00:00:00 2001
From: Matej Vasek <mvasek@redhat.com>
Date: Fri, 21 Jan 2022 18:49:17 +0100
Subject: [PATCH] :open_file_folder: update OpenShift specific files

Use OpenShift specific transport/registry

Signed-off-by: Matej Vasek <mvasek@redhat.com>
---
 cmd/build.go                |   9 +-
 cmd/deploy.go               |   9 +-
 cmd/invoke.go               |   5 +-
 openshift/openshift.go      | 175 ++++++++++++++++++++++++++++++++++++
 openshift/openshift_test.go |  26 ++++++
 5 files changed, 214 insertions(+), 10 deletions(-)
 create mode 100644 openshift/openshift.go
 create mode 100644 openshift/openshift_test.go

diff --git a/cmd/build.go b/cmd/build.go
index 82bce0e3..f6087519 100644
--- a/cmd/build.go
+++ b/cmd/build.go
@@ -5,8 +5,6 @@ import (
 	"fmt"
 	"net/http"
 
-	fnhttp "knative.dev/kn-plugin-func/http"
-
 	"github.com/AlecAivazis/survey/v2"
 	"github.com/AlecAivazis/survey/v2/terminal"
 	"github.com/ory/viper"
@@ -17,6 +15,8 @@ import (
 	"knative.dev/kn-plugin-func/docker"
 	"knative.dev/kn-plugin-func/docker/creds"
 	"knative.dev/kn-plugin-func/progress"
+
+	"knative.dev/kn-plugin-func/openshift"
 )
 
 func init() {
@@ -35,6 +35,7 @@ func newBuildClient(cfg buildConfig) (*fn.Client, error) {
 	)
 	if cfg.Push {
 		credentialsProvider := creds.NewCredentialsProvider(
+			creds.WithAdditionalCredentialLoaders(openshift.GetDockerCredentialLoaders()...),
 			creds.WithPromptForCredentials(newPromptForCredentials()),
 			creds.WithPromptForCredentialStore(newPromptForCredentialStore()),
 			creds.WithTransport(cfg.Transport))
@@ -95,7 +96,7 @@ kn func build --builder cnbs/sample-builder:bionic
 	cmd.Flags().StringP("builder", "b", "", "Buildpack builder, either an as a an image name or a mapping name.\nSpecified value is stored in func.yaml for subsequent builds.")
 	cmd.Flags().BoolP("confirm", "c", false, "Prompt to confirm all configuration options (Env: $FUNC_CONFIRM)")
 	cmd.Flags().StringP("image", "i", "", "Full image name in the form [registry]/[namespace]/[name]:[tag] (optional). This option takes precedence over --registry (Env: $FUNC_IMAGE)")
-	cmd.Flags().StringP("registry", "r", "", "Registry + namespace part of the image to build, ex 'quay.io/myuser'.  The full image name is automatically determined based on the local directory name. If not provided the registry will be taken from func.yaml (Env: $FUNC_REGISTRY)")
+	cmd.Flags().StringP("registry", "r", openshift.GetDefaultRegistry(), "Registry + namespace part of the image to build, ex 'quay.io/myuser'.  The full image name is automatically determined based on the local directory name. If not provided the registry will be taken from func.yaml (Env: $FUNC_REGISTRY)")
 	cmd.Flags().BoolP("push", "u", false, "Attempt to push the function image after being successfully built")
 	setPathFlag(cmd)
 
@@ -191,7 +192,7 @@ func runBuild(cmd *cobra.Command, _ []string, clientFn buildClientFn) (err error
 		config.Registry = ""
 	}
 
-	rt := fnhttp.NewRoundTripper()
+	rt := openshift.NewRoundTripper()
 	defer rt.Close()
 	config.Transport = rt
 
diff --git a/cmd/deploy.go b/cmd/deploy.go
index cdd6da2a..a26e0979 100644
--- a/cmd/deploy.go
+++ b/cmd/deploy.go
@@ -7,8 +7,6 @@ import (
 	"os"
 	"strings"
 
-	fnhttp "knative.dev/kn-plugin-func/http"
-
 	"github.com/AlecAivazis/survey/v2"
 	"github.com/AlecAivazis/survey/v2/terminal"
 	"github.com/ory/viper"
@@ -22,6 +20,8 @@ import (
 	"knative.dev/kn-plugin-func/knative"
 	"knative.dev/kn-plugin-func/pipelines/tekton"
 	"knative.dev/kn-plugin-func/progress"
+
+	"knative.dev/kn-plugin-func/openshift"
 )
 
 func init() {
@@ -38,6 +38,7 @@ func newDeployClient(cfg deployConfig) (*fn.Client, error) {
 	)
 
 	credentialsProvider := creds.NewCredentialsProvider(
+		creds.WithAdditionalCredentialLoaders(openshift.GetDockerCredentialLoaders()...),
 		creds.WithPromptForCredentials(newPromptForCredentials()),
 		creds.WithPromptForCredentialStore(newPromptForCredentialStore()),
 		creds.WithTransport(cfg.Transport))
@@ -118,7 +119,7 @@ kn func deploy --image quay.io/myuser/myfunc -n myns
 		"You may provide this flag multiple times for setting multiple environment variables. "+
 		"To unset, specify the environment variable name followed by a \"-\" (e.g., NAME-).")
 	cmd.Flags().StringP("image", "i", "", "Full image name in the form [registry]/[namespace]/[name]:[tag] (optional). This option takes precedence over --registry (Env: $FUNC_IMAGE)")
-	cmd.Flags().StringP("registry", "r", "", "Registry + namespace part of the image to build, ex 'quay.io/myuser'.  The full image name is automatically determined based on the local directory name. If not provided the registry will be taken from func.yaml (Env: $FUNC_REGISTRY)")
+	cmd.Flags().StringP("registry", "r", openshift.GetDefaultRegistry(), "Registry + namespace part of the image to build, ex 'quay.io/myuser'.  The full image name is automatically determined based on the local directory name. If not provided the registry will be taken from func.yaml (Env: $FUNC_REGISTRY)")
 	cmd.Flags().StringP("build", "b", fn.DefaultBuildType, fmt.Sprintf("Build specifies the way the function should be built. Supported types are %s (Env: $FUNC_BUILD)", fn.SupportedBuildTypes(true)))
 	cmd.Flags().BoolP("push", "u", true, "Attempt to push the function image to registry before deploying (Env: $FUNC_PUSH)")
 	setPathFlag(cmd)
@@ -220,7 +221,7 @@ func runDeploy(cmd *cobra.Command, _ []string, clientFn deployClientFn) (err err
 		config.Registry = ""
 	}
 
-	rt := fnhttp.NewRoundTripper()
+	rt := openshift.NewRoundTripper()
 	defer rt.Close()
 	config.Transport = rt
 
diff --git a/cmd/invoke.go b/cmd/invoke.go
index b7e523dd..7ff8465c 100644
--- a/cmd/invoke.go
+++ b/cmd/invoke.go
@@ -14,8 +14,9 @@ import (
 	"knative.dev/kn-plugin-func/utils"
 
 	fn "knative.dev/kn-plugin-func"
-	fnhttp "knative.dev/kn-plugin-func/http"
 	knative "knative.dev/kn-plugin-func/knative"
+
+	"knative.dev/kn-plugin-func/openshift"
 )
 
 func init() {
@@ -33,7 +34,7 @@ func newInvokeClient(cfg invokeConfig) (*fn.Client, error) {
 
 	return fn.New(
 		fn.WithDescriber(describer),
-		fn.WithTransport(fnhttp.NewRoundTripper()),
+		fn.WithTransport(openshift.NewRoundTripper()),
 		fn.WithVerbose(cfg.Verbose),
 	), nil
 }
diff --git a/openshift/openshift.go b/openshift/openshift.go
new file mode 100644
index 00000000..b9ee148b
--- /dev/null
+++ b/openshift/openshift.go
@@ -0,0 +1,175 @@
+package openshift
+
+import (
+	"context"
+	"crypto/x509"
+	"encoding/pem"
+	"errors"
+	"strings"
+	"sync"
+	"time"
+
+	v1 "k8s.io/api/core/v1"
+	k8sErrors "k8s.io/apimachinery/pkg/api/errors"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/fields"
+	"k8s.io/apimachinery/pkg/util/rand"
+
+	"knative.dev/kn-plugin-func/docker"
+	"knative.dev/kn-plugin-func/docker/creds"
+	fnhttp "knative.dev/kn-plugin-func/http"
+	"knative.dev/kn-plugin-func/k8s"
+)
+
+const (
+	registryHost     = "image-registry.openshift-image-registry.svc"
+	registryHostPort = registryHost + ":5000"
+)
+
+func GetServiceCA(ctx context.Context) (*x509.Certificate, error) {
+	client, ns, err := k8s.NewClientAndResolvedNamespace("")
+	if err != nil {
+		return nil, err
+	}
+
+	cfgMapName := "service-ca-config-" + rand.String(5)
+
+	cfgMap := &v1.ConfigMap{
+		ObjectMeta: metav1.ObjectMeta{
+			Name:        cfgMapName,
+			Annotations: map[string]string{"service.beta.openshift.io/inject-cabundle": "true"},
+		},
+	}
+
+	configMaps := client.CoreV1().ConfigMaps(ns)
+
+	nameSelector := fields.OneTermEqualSelector("metadata.name", cfgMapName).String()
+	listOpts := metav1.ListOptions{
+		Watch:         true,
+		FieldSelector: nameSelector,
+	}
+
+	watch, err := configMaps.Watch(ctx, listOpts)
+	if err != nil {
+		return nil, err
+	}
+	defer watch.Stop()
+
+	crtChan := make(chan string)
+	go func() {
+		for event := range watch.ResultChan() {
+			cm, ok := event.Object.(*v1.ConfigMap)
+			if !ok {
+				continue
+			}
+			if crt, ok := cm.Data["service-ca.crt"]; ok {
+				crtChan <- crt
+				close(crtChan)
+				break
+			}
+		}
+	}()
+
+	_, err = configMaps.Create(ctx, cfgMap, metav1.CreateOptions{})
+	if err != nil {
+		return nil, err
+	}
+	defer func() {
+		_ = configMaps.Delete(ctx, cfgMapName, metav1.DeleteOptions{})
+	}()
+
+	select {
+	case crt := <-crtChan:
+		blk, _ := pem.Decode([]byte(crt))
+		return x509.ParseCertificate(blk.Bytes)
+	case <-time.After(time.Second * 5):
+		return nil, errors.New("failed to get OpenShift's service CA in time")
+	}
+}
+
+func NewRoundTripper() fnhttp.RoundTripCloser {
+	if !IsOpenShift() {
+		return fnhttp.NewRoundTripper()
+	}
+
+	var selectCA func(ctx context.Context, serverName string) (*x509.Certificate, error)
+	ca, err := GetServiceCA(context.TODO())
+	if err == nil {
+		selectCA = func(ctx context.Context, serverName string) (*x509.Certificate, error) {
+			if strings.HasPrefix(serverName, registryHost) {
+				return ca, nil
+			}
+			return nil, nil
+		}
+	}
+	return fnhttp.NewRoundTripper(fnhttp.WithSelectCA(selectCA))
+}
+
+func GetDefaultRegistry() string {
+	if !IsOpenShift() {
+		return ""
+	}
+
+	ns, _ := k8s.GetNamespace("")
+	if ns == "" {
+		ns = "default"
+	}
+
+	return registryHostPort + "/" + ns
+}
+
+func GetDockerCredentialLoaders() []creds.CredentialsCallback {
+	if !IsOpenShift() {
+		return nil
+	}
+
+	conf := k8s.GetClientConfig()
+
+	rawConf, err := conf.RawConfig()
+	if err != nil {
+		return nil
+	}
+
+	cc := rawConf.Contexts[rawConf.CurrentContext]
+	authInfo := rawConf.AuthInfos[cc.AuthInfo]
+
+	user := "user"
+	parts := strings.SplitN(cc.AuthInfo, "/", 2)
+	if len(parts) >= 1 {
+		user = parts[0]
+	}
+	credentials := docker.Credentials{
+		Username: user,
+		Password: authInfo.Token,
+	}
+
+	return []creds.CredentialsCallback{
+		func(registry string) (docker.Credentials, error) {
+			if registry == registryHostPort {
+				return credentials, nil
+			}
+			return docker.Credentials{}, nil
+		},
+	}
+
+}
+
+var isOpenShift bool
+var onceIsOpenShift sync.Once
+
+func IsOpenShift() bool {
+	onceIsOpenShift.Do(func() {
+		client, err := k8s.NewKubernetesClientset()
+		if err != nil {
+			isOpenShift = false
+			return
+		}
+		_, err = client.CoreV1().Services("openshift-image-registry").Get(context.TODO(), "image-registry", metav1.GetOptions{})
+		if k8sErrors.IsNotFound(err) {
+			isOpenShift = false
+			return
+		}
+		isOpenShift = true
+	})
+	return isOpenShift
+}
diff --git a/openshift/openshift_test.go b/openshift/openshift_test.go
new file mode 100644
index 00000000..4573e0e7
--- /dev/null
+++ b/openshift/openshift_test.go
@@ -0,0 +1,26 @@
+//go:build integration
+// +build integration
+
+package openshift_test
+
+import (
+	"net/http"
+	"testing"
+
+	"knative.dev/kn-plugin-func/openshift"
+)
+
+func TestRoundTripper(t *testing.T) {
+	transport := openshift.NewRoundTripper()
+
+	client := http.Client{
+		Transport: transport,
+	}
+
+	resp, err := client.Get("https://image-registry.openshift-image-registry.svc.cluster.local:5000/v2/")
+	if err != nil {
+		t.Error(err)
+		return
+	}
+	defer resp.Body.Close()
+}
-- 
2.31.1

